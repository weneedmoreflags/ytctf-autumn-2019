# Bad formatting 2 - Reverse, 250 баллов

При запуске программы из первой части таска можно было заметить, что она, помимо вывода флага, еще и просит ввести другой. Давайте попробуем понять, какой же флажок придется ей по вкусу.

На том же [сайте](https://vii5ard.github.io/whitespace/), что и в первой части, справа можно было заметить своеобразный отладчик. Давайте немного потрассируем код из таска и попытаемся понять, что же он делает. 

Начнем с простого. `label_1` работает в цикле, да еще и содержит команду `printc`. Функция явно печатает строку, лежащую на стеке. 
```
label_1:
  dup
  jz label_13
  printc
  jmp label_1
label_13:
  drop
  ret
```
Рядом находятся и `label_10`, и `label_11`, которые используют `label_1`. Если мы переведем значения, которые кладутся в них на стек, придем к выводу, что `label_10` печатает `Good`, а `label_11` - `Bad`. 
```
label_10:
  swap
  sub
  jn label_11
  push 0
  push 100
  push 111
  push 111
  push 71
  call label_1
label_11:
  push 0
  push 100
  push 97
  push 66
  call label_1
  jmp label_12
label_12:
  end
```
Точка входа `label_0` несколько раз вызывает `label_1`, однако после этого она кладет на стек какие-то число, явно не являющиеся ASCII-кодами:
```
push 26
push 54
push 41
push 69
push 65
push 1
push 4
push 12
push 29
push 33
```
Ясно, что скорее всего они как-то используются для проверки введенного флага. Попытаемся понять, как. В `label_2` считывается введенная пользователем строка (что можно понять по инструкции `readc`). 
Что делает `label_3`? Поставим бряку где-нибудь в конце и посмотрим на память интерпретатора (в качестве строки я ввел `0123456789`)

![Interpreter memory](1.png)

**Флаг:** `ytctf{wsr3v_is_n0teasy}`
